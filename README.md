# A64 ISA XML for A-profile Architecture (2025-03)

## Release Date 2025-05-30

## Introduction

This is the *2025-03* release of the A64
ISA XML for A-profile Architecture.

The [Proprietary
Notice](ISA_A64_xml_A_profile-2025-03/xhtml/notice.html) gives details
of the terms and conditions under which this package is provided.

If you have comments on the content of this package, create a ticket at
<https://support.developer.arm.com>. As part of the ticket, include:

- The title, \"A64 ISA XML for A-profile Architecture\".
- The version, \"2025-03\".
- The section name to which your comments refer.
- A concise explanation of your comments.

## Product Status

The information relating to the 2024 Extensions is at Alpha quality.
Alpha quality means that most major features of the specification are
described in this release, but some features and details might be
missing. The information relating to the rest of the A-profile
Architecture is at Beta quality. Beta quality means that all major
features of the specification are described, but some details might be
missing.​

### Change history

The following changes are made to instruction descriptions:

- The description for ADDQV is updated to remove the term \"unsigned\".
- In the Advanced SIMD \"USUBW, USUBW2\" instructions, the text
  describing which register has its top or bottom half selected is
  corrected to match the pseudocode.
- The SETG\* instruction encodings are updated to add FEAT_MTE as a
  condition.
- In PRFM and PRFUM, the example of what the memory system can do to
  speed up memory accesses is clarified.

The following changes are made to the pseudocode:

- In function AArch64.S1TTWParamsEL10(), the value of register PIRE0_EL1
  is treated as 0 if SCR_EL3.PIEn is 0 or the Effective value of
  HCR_EL2.NV1 is 1.
- In the Advanced SIMD scalar FP convert instruction decode pseudocode,
  FEAT_FPRCVT is tested instead of FEAT_SME2p2.
- Functions like AArch64.S1POR() and AArch64.S1TTWParamsEL2() are
  updated to check return zero when SCR_EL3.PIEn is 0.
- The early return condition in CheckForTRBEException is updated.
- The function AArch64.isPARFormatD128 is corrected to call
  isTCR2ELxEnabled() before accessing TCR2_ELx.
- The function PhysicalSErrorTarget() is corrected to remove a check
  that is not needed in EL3.
- The pseudocode functions Hint_WFE() and Hint_WFET() are corrected to
  cause a trap even if FEAT_TWED is not implemented.
- The functions AArch64.MemSingleRead() and AArch64.MemSingleWrite() are
  corrected to clarify that they do not guarantee single-copy atomicity
  for memory accesses generated by Load-Acquire or Store-Release
  instructions.
- The pseudocode function EffectiveEA() is corrected to treat SCR.EA as
  0.
- In the pseudocode function TLBIMatch(), the condition to return the
  TLBI match as false based on the XS attribute is removed.
- The following pseudocode functions are updated to take bits type
  parameters instead of integers:
  - AArch64.SysInstr()
  - AArch64.SysInstr128()
  - AArch64.SysInstrWithResult()
  - AArch64.SysRegRead128()
  - AArch64.SysRegWrite()
  - AArch64.SysRegWrite128()
  - AArch64.CheckSystemAccess()
  - AArch64.CheckTransactionalSystemAccess()

  The el parameter is removed from AArch64.ImpDefSysInstr(),
  AArch64.ImpDefSysInstr128(), and AArch64.ImpDefSysInstrWithResult().
  An integer t parameter is added to AArch64.ImpDefSysInstrWithResult().
- The pseudocode function signatures having a DIV operator in their
  arguments for bit widths are modified to retain functionality and not
  use the DIV operator.
- Pseudocode support for FEAT_TRBE_EXT is added.
- The shift amount in the following Advanced SIMD instructions is
  saturated to the element width by the ShiftSat() function. This is for
  consistency with the equivalent SVE instructions, but has no material
  impact on the behavior of the instructions.
- The function AArch64.SettingDirtyStatePermitted() is corrected to
  specify that setting the dirty state is allowed only if no Permission
  Fault occurs. Similar changes are made to ensure this behavior in the
  functions AArch64.SetDirtyFlag(), AArch64.S2Translate(), and
  AArch64.S1Translate().
- The function AArch64.SHAmajority() is updated to accept both 32-bit
  and 64-bit values. The operation SHA512H2 is updated to use
  AArch64.SHAMajority.

Many simple clarifications and corrections are also present, but are too
small to be listed here. Some minor formatting changes are suppressed
and not highlighted in the diff output.

### Limitations of Arm pseudocode

The pseudocode statements IMPLEMENTATION_DEFINED, SEE, UNDEFINED, and
UNPREDICTABLE indicate behavior that differs from that indicated by the
pseudocode being executed. If one of them is encountered:

- Earlier behavior indicated by the pseudocode is only specified as
  occurring to the extent required to determine that the statement is
  executed.
- No subsequent behavior indicated by the pseudocode occurs.

For more information, see [Special
statements]{style="font-style: italic;"} in the Arm® Architecture
Reference Manual for A-profile architecture (ARM DDI 0487).

The pseudocode descriptions have several limitations. These are mainly
since, for clarity and brevity, the pseudocode is a sequential and
mostly deterministic language.

These limitations include:

Pseudocode does not describe the ordering requirements when an
instruction generates multiple memory accesses. For a description of the
ordering requirements on memory accesses, see [External ordering
constraints]{style="font-style: italic;"} in the Arm® Architecture
Reference Manual for A-profile architecture (ARM DDI 0487).

Pseudocode does not describe the exact ordering requirements when a
single floating-point instruction generates more than one floating-point
exception and one or more of those floating-point exceptions is trapped.
[Combinations of floating-point exceptions]{style="font-style: italic;"}
in the Arm® Architecture Reference Manual for A-profile architecture
(ARM DDI 0487) describes the exact rules. **Note:** There is no
limitation in the case where all the floating-point exceptions are
untrapped, because the pseudocode specifies the same behavior as the
referenced section.

When the architectural behavior of an instruction could be performed as
a concurrent set of operations that are not architecturally ordered, the
pseudocode represents it as a sequential set of operations.

An exception can be taken during execution of the pseudocode for an
instruction, either explicitly as a result of the execution of a
pseudocode function such as Abort(), or implicitly, for example if an
interrupt is taken during execution of an LDM instruction, load-store
pair instructions, SVE vector instructions, Memory copy and memory set
instructions etc.. If this happens, the pseudocode does not describe the
extent to which the normal behavior of the instruction occurs. To
determine that, see the descriptions of the exceptions in *Handling
exceptions that are taken to an Exception level using AArch32 and
Definition of a precise exception and imprecise
exception* in the Arm® Architecture
Reference Manual for A-profile architecture (ARM DDI 0487).

Pseudocode does not describe the exact rules when an AArch32 instruction
that that fails its condition code check generates any of the following:

- UNDEFINED instruction.
- Hyp trap.
- Monitor trap.
- Trap to AArch64 exception.

In such cases, the UNDEFINED pseudocode statement or call to the
applicable trap function lies inside the if ConditionPassed() then \...
structure, either directly or in the EncodingSpecificOperations()
function call, and so the pseudocode indicates that the instruction
executes as a NOP. For the exact rules, see ARM DDI 0487 sections:

- *Conditional execution of undefined
  instructions*.
- *EL2 configurable controls*.
- *EL3 configurable controls*.
- *Configurable instruction controls*.

Where a significant aspect of the behavior is IMPLEMENTATION DEFINED,
pseudocode may present only the declarations of the functions - the
details of these functions is provided by each implementation of the
architecture.

Pseudocode does not present the possible observability due to
speculative execution.

Pseudocode presents various details of the architecture - but does not
show how the details can be combined to form a complete implementation.
There are various aspects of an implementation that are also not
presented. Notably, pseudocode does not show the details of fetching,
decoding, and linking to instruction execution.

Pseudocode presents all the architectural state as global state. The
possible implications of multiple PEs or other components is not shown.

The following details are either not shown or have noted limitations in
the pseudocode:

- Self-hosted trace and external trace.
- Modeling the System register state or side effects. The accessibility
  details of a direct or external access such as traps etc are shown.
- Generation of all architectural and micro-architectural Performance
  Monitoring Events. **Note**: Some architectural event generation is
  shown.
- Construction of Statistical Profiling Extension records.
- Statistical Profiling functionality for 2023 features.
- Behavior of instructions in Debug state when the behavior is
  UNPREDICTABLE is presented as if the instruction is executed
  identically to how it is when not in Debug state.
- Activity Monitor Events and Counters.
- Generic Interrupt Controller functionality.
- External memory system.
- External agents such as a debugger.
- PE behaviors that would lead to unrecoverable or uncontainable errors.
- Where the behavior is IMPLEMENTATION DEFINED or CONSTRAINED
  UNPREDICTABLE, not all possibilities may be shown. Sometimes the
  pseudocode may present a simplified, but architecturally compatible
  view. In some situations, the possible behaviors may be outlined in a
  comment.

The following architectural features are at Alpha quality and are above
the limitations described below due to recency and completion of
validation:

- Halting Debug
- Statistical Profiling Extension.
- Performance Monitoring Events.

### Known issues

All issues identified in the below list will be fixed in a future
release.

The assembler syntax for MRS and MSR instructions with unnamed registers
will be clarified.

In the following SME instructions, the feature conditions stated in the
pseudocode are correct, but the feature conditions stated above the
encoding diagrams are incomplete:

- SMLALL (multiple vectors), SMLALL (multiple and single vector).
- SMLSLL (multiple vectors), SMLSLL (multiple and single vector).
- UMLALL (multiple vectors), UMLALL (multiple and single vector).
- UMLSLL (multiple vectors), UMLSLL (multiple and single vector).
- SDOT (4-way, multiple and single vector), SDOT (4-way, multiple
  vectors).
- UDOT (4-way, multiple and single vector), UDOT (4-way, multiple
  vectors).
- FMLA (multiple and single vector), FMLA (multiple vectors).
- FMLS (multiple and single vector), FMLS (multiple vectors).
- ADD (array results, multiple and single vector), ADD (array results,
  multiple vectors), ADD (array accumulators).
- SUB (array results, multiple and single vector), SUB (array results,
  multiple vectors), SUB (array accumulators).
- FADD.
- FSUB.

CONSTRAINED UNPREDICTABLE update of S2AP\[1\] for fault on atomic access
with DBM\[1\] and S2AP\[0:1\] is 0b00 when read permission is not
present.

SVE instructions that were defined prior to FEAT_SVE2 but which are
required to honor PSTATE.DIT when FEAT_SVE2 is implemented will have the
\"If FEAT_SVE2 is implemented or FEAT_SME is implemented\" condition on
their PSTATE.DIT behavior restored.

### Potential Upcoming Changes

The details of the architecture are presented in pseudocode in
Architecture Specification Language (ASL). Arm is defining a new version
of the Architecture Specification Language, ASL1, to improve and expand
the capabilities of the language. Please see
https://developer.arm.com/Architectures/Architecture%20Specification%20Language
for details on this language. Arm will be publishing an equivalent
release in ASL1 format later in 2025.

### Intention and quality statements for all ArmARM architecture releases

The intention and scope of the **Architecture releases** is to describe
changes from the existing architecture to the next release. The quality
of the architecture releases refers to the accuracy and completeness of
the changes described in the specifications.

The intention and scope of the **XML releases** is to describe the
content and behavior of the registers, system registers, instructions,
pseudocode and features of the architecture in full, for human readers
in a way that enables correct information for the current or any
previous release can be deduced. The quality of the XML releases refers
to the accuracy and completeness of the content to a human reader.

The intention and scope of the **JSON releases** is to describe aspects
of the XML releases in a structured, machine readable format. The
content of the architectural content will be approximately equivalent to
the corresponding XML release. However there are some aspects of the
architecture which cannot yet be represented in a machine readable
format.

The intention and scope of the **Schema** for the JSON releases is to
describe the syntax and format of the json files used in the json
releases. The schema is still under development and is subject to
change.
